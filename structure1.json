{
  "src": {
    "modules": {
      "payments": {
        "dto": {
          "generate-qr.dto.ts": "/* import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { IsNumber, IsOptional, IsString } from 'class-validator';\r\n\r\nexport class GenerateQRDto {\r\n  @ApiProperty({\r\n    description: 'Order Id',\r\n    example: 1,\r\n  })\r\n  @IsNumber()\r\n  ticketId: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'gloss',\r\n    example: 'PAGO APP Buses',\r\n  })\r\n  @IsString()\r\n  @IsOptional()\r\n  gloss?: string;\r\n}\r\n */\r\n\r\nimport {\r\n  IsString,\r\n  IsNumber,\r\n  IsOptional,\r\n  IsBoolean,\r\n  IsArray,\r\n  ValidateNested,\r\n  MaxLength,\r\n  Min,\r\n  Matches,\r\n  IsIn,\r\n} from 'class-validator';\r\nimport { Type } from 'class-transformer';\r\n\r\n/* ====================================================================================== */\r\n/*                                   Collector DTO                                        */\r\n/* ====================================================================================== */\r\n\r\nexport class CollectorDto {\r\n  @IsString()\r\n  name: string;\r\n\r\n  @IsString()\r\n  parameter: string;\r\n\r\n  @IsString()\r\n  value: string;\r\n}\r\n\r\n/* ====================================================================================== */\r\n/*                                   Generate QR DTO                                      */\r\n/* ====================================================================================== */\r\n\r\nexport class GenerateQrDto {\r\n  @IsString()\r\n  @IsIn(['BOB', 'USD'])\r\n  currency: string;\r\n\r\n  @Type(() => Number)\r\n  @IsNumber({ maxDecimalPlaces: 2 })\r\n  @Min(0)\r\n  amount: number;\r\n\r\n  @IsString()\r\n  @MaxLength(60)\r\n  gloss: string;\r\n\r\n  @IsOptional()\r\n  @Type(() => Boolean)\r\n  @IsBoolean()\r\n  singleUse?: boolean;\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  enableBank?: string; // puedes restringir con @IsIn(['ALL']) si solo permites ALL\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  city?: string;\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  branchOffice?: string;\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  teller?: string;\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  @Matches(/^\\d{7,15}$/, {\r\n    message: 'phoneNumber debe contener solo números (7 a 15 dígitos)',\r\n  })\r\n  phoneNumber?: string;\r\n\r\n  @IsOptional()\r\n  @IsString()\r\n  @Matches(/^\\d{2}\\/\\d{2}:\\d{2}$/, {\r\n    message: 'expiration debe tener el formato DD/HH:mm (ej: 01/02:00)',\r\n  })\r\n  expiration?: string;\r\n\r\n  @IsOptional()\r\n  @IsArray()\r\n  @ValidateNested({ each: true })\r\n  @Type(() => CollectorDto)\r\n  collectors?: CollectorDto[];\r\n}\r\n",
          "qr-callback.dto.ts": "export class QrCallbackDto {\r\n  IdCorrelation: string;\r\n  Id: number;\r\n  ServiceCode: string;\r\n  BusinessCode: string;\r\n  IdQr: string;\r\n  Eif?: string;\r\n  Account?: string;\r\n  Amount: number;\r\n  Currency: string;\r\n  Gloss: string;\r\n  ReceiverAccount: string;\r\n  ReceiverName: string;\r\n  ReceiverDocument: string;\r\n  ReceiverBank: string;\r\n  Status: string;\r\n  RequestDate: string;\r\n  State: boolean;\r\n  CorrelationId: string;\r\n  Description: string;\r\n  GenerateType: number;\r\n  Version: string;\r\n  SingleUse: boolean;\r\n  OperationNumber: string;\r\n  City: string;\r\n  BranchOffice: string;\r\n  Teller: string;\r\n  PhoneNumber: string;\r\n  Collectors: CollectorDto[];\r\n}\r\n\r\nexport class CollectorDto {\r\n  Name: string;\r\n  Parameter: string;\r\n  Value: string;\r\n}\r\n"
        },
        "entities": {
          "payment-qr.entity.ts": "import {\r\n  Column,\r\n  CreateDateColumn,\r\n  Entity,\r\n  JoinColumn,\r\n  OneToOne,\r\n  PrimaryGeneratedColumn,\r\n} from 'typeorm';\r\n\r\nimport { Ticket } from 'src/modules/tickets/entities/ticket.entity';\r\n\r\n@Entity('payments-qr')\r\nexport class PaymentQR {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column('text')\r\n  qrId: string;\r\n\r\n  @Column('text')\r\n  qrImage: string;\r\n\r\n  @Column({ type: 'decimal', precision: 10, scale: 2 })\r\n  amount: string;\r\n\r\n  @Column('text')\r\n  gloss: string;\r\n\r\n  @CreateDateColumn({\r\n    type: 'timestamptz',\r\n  })\r\n  createdAt: Date;\r\n\r\n  //* ============================================================================================== */\r\n  //*                                        Relations                                               */\r\n  //* ============================================================================================== */\r\n\r\n  @OneToOne(() => Ticket, (ticket) => ticket.paymentQr)\r\n  //@JoinColumn()\r\n  ticket: Ticket;\r\n}\r\n"
        },
        "guards": {
          "basic-auth.guard.ts": "import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\r\nimport { Response } from 'express';\r\nimport { envs } from 'src/config/environments/environments';\r\n\r\n@Injectable()\r\nexport class BasicAuthGuard implements CanActivate {\r\n  canActivate(context: ExecutionContext): boolean {\r\n    const request = context.switchToHttp().getRequest();\r\n    const response = context.switchToHttp().getResponse<Response>();\r\n\r\n    const authHeader = request.headers['authorization'];\r\n\r\n    if (!authHeader || !authHeader.startsWith('Basic ')) {\r\n      response.status(200).json({\r\n        State: '003',\r\n        Mensaje: 'Credenciales incorrectas',\r\n        Data: {\r\n          id: `E-${Date.now()}`,\r\n        },\r\n      });\r\n      return false;\r\n    }\r\n\r\n    const base64Credentials = authHeader.split(' ')[1];\r\n    const credentials = Buffer.from(base64Credentials, 'base64').toString(\r\n      'ascii',\r\n    );\r\n    const [username, password] = credentials.split(':');\r\n\r\n    if (username !== envs.BCP_USER || password !== envs.BCP_PUBLIC_TOKEN) {\r\n      response.status(200).json({\r\n        State: '003',\r\n        Mensaje: 'Credenciales incorrectas',\r\n        Data: {\r\n          id: `E-${Date.now()}`,\r\n        },\r\n      });\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n"
        },
        "http": {
          "http.service.ts": "import { Injectable } from '@nestjs/common';\r\nimport * as https from 'https';\r\nimport axios from 'axios';\r\nimport * as fs from 'fs';\r\nimport { join } from 'path';\r\n\r\nimport { envs } from 'src/config/environments/environments';\r\nimport { GenerateQrDto } from '../dto/generate-qr.dto';\r\nimport { BcpQrResponse } from '../interfaces/bcp-qr.interface';\r\n\r\n@Injectable()\r\nexport class HttpService {\r\n  private readonly axiosInstance: ReturnType<typeof axios.create>;\r\n\r\n  constructor() {\r\n    // Leer el certificado PFX\r\n    const certPath = join(\r\n      process.cwd(),\r\n      'src/certs/sandbox.openbanking.bcp.com.bo.pfx',\r\n    );\r\n\r\n    const pfxBuffer = fs.readFileSync(certPath);\r\n\r\n    // Configurar el agente HTTPS con el certificado\r\n    const httpsAgent = new https.Agent({\r\n      pfx: pfxBuffer,\r\n      passphrase: envs.BCP_PASSPHRASE, //'Sandbox2025',\r\n      servername: envs.BCP_SERVER_NAME, //'sandbox.openbanking.bcp.com.bo',\r\n      rejectUnauthorized: true, // IMPORTANTE: poner true\r\n      secureProtocol: 'TLSv1_2_method',\r\n    });\r\n\r\n    // Crear instancia de Axios\r\n    this.axiosInstance = axios.create({\r\n      baseURL: envs.BCP_URL, //'https://sandbox.openbanking.bcp.com.bo',\r\n      timeout: 30000,\r\n      httpsAgent: httpsAgent,\r\n      validateStatus: () => true,\r\n      maxBodyLength: Infinity,\r\n      maxContentLength: Infinity,\r\n    } as any);\r\n  }\r\n\r\n  async generateQr(dto: GenerateQrDto): Promise<BcpQrResponse> {\r\n    try {\r\n      const user = envs.BCP_USER;\r\n      const password = envs.BCP_PASSWORD;\r\n      const authString = `${user}:${password}`;\r\n      const base64Auth = Buffer.from(authString).toString('base64');\r\n\r\n      const headers = {\r\n        'Content-Type': 'application/json',\r\n        'Correlation-Id': this.generateCorrelationId(),\r\n        Authorization: `Basic ${base64Auth}`,\r\n      };\r\n\r\n      const requestBody = {\r\n        appUserId: envs.BCP_APP_USER_ID,\r\n        currency: dto.currency,\r\n        amount: dto.amount,\r\n        gloss: dto.gloss || '',\r\n        serviceCode: '050',\r\n        businessCode: envs.BCP_BUSINESS_CODE,\r\n        singleUse: dto.singleUse ?? false,\r\n        enableBank: dto.enableBank || 'ALL',\r\n        city: dto.city || '',\r\n        branchOffice: dto.branchOffice || '',\r\n        teller: dto.teller || '',\r\n        phoneNumber: dto.phoneNumber || '',\r\n        publicToken: envs.BCP_PUBLIC_TOKEN,\r\n        expiration: dto.expiration || '00/00:00',\r\n        collectors: dto.collectors || [],\r\n      };\r\n\r\n      const response = await this.axiosInstance.post(\r\n        '/Web_ApiQr/api/v4/Qr/Generated',\r\n        requestBody,\r\n        { headers },\r\n      );\r\n\r\n      const responseData = response.data as BcpQrResponse;\r\n\r\n      if (responseData.state !== '00') {\r\n        throw {\r\n          state: responseData.state,\r\n          message: responseData.message,\r\n          details: responseData,\r\n        };\r\n      }\r\n\r\n      return responseData;\r\n    } catch (error) {\r\n      if (error.response?.data) {\r\n        throw {\r\n          state: error.response.data.state || '99',\r\n          message: error.response.data.message || 'Error general',\r\n          details: error.response.data,\r\n        };\r\n      }\r\n      throw {\r\n        state: '99',\r\n        message: 'Error de comunicación',\r\n        details: error.message,\r\n      };\r\n    }\r\n  }\r\n\r\n  private generateCorrelationId(): string {\r\n    // Formato: 0001-001-123456\r\n    const timestamp = Date.now().toString().slice(-6);\r\n    return `0001-001-${timestamp}`;\r\n  }\r\n}\r\n"
        },
        "interfaces": {
          "bcp-qr.interface.ts": "export interface BcpQrResponse {\r\n  data: {\r\n    id: number;\r\n    qrImage: string; // Base64\r\n    expirationDate: string; // yyyy-MM-dd HH:mm\r\n  };\r\n  state: string; // '00' = Correcto\r\n  message: string;\r\n}\r\n",
          "generate-qr.interface.ts": "export interface GenerateQrInterface {\r\n  currency: string; // BOB, USD\r\n  amount: number; // 150.69 o 0 para editable\r\n  gloss: string; // 60 caracteres máximo\r\n  singleUse?: boolean;\r\n  enableBank?: string; // 'ALL' por defecto\r\n  city?: string;\r\n  branchOffice?: string;\r\n  teller?: string;\r\n  phoneNumber?: string;\r\n  expiration?: string; // Formato: dia/hora:minutos (ej: 01/02:00)\r\n  collectors?: CollectorInterface[];\r\n}\r\n\r\nexport interface CollectorInterface {\r\n  name: string;\r\n  parameter: string;\r\n  value: string;\r\n}\r\n"
        },
        "payments.controller.ts": "import { Controller, Post, Body, UseGuards } from '@nestjs/common';\r\nimport { randomUUID } from 'crypto';\r\n\r\nimport { BasicAuthGuard } from './guards/basic-auth.guard';\r\n\r\nimport { GenerateQrDto } from './dto/generate-qr.dto';\r\nimport { QrCallbackDto } from './dto/qr-callback.dto';\r\n\r\nimport { PaymentsService } from './payments.service';\r\n\r\n@Controller('payments')\r\nexport class PaymentsController {\r\n  constructor(private readonly paymentsService: PaymentsService) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                   Generate_QR                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  @Post('generate')\r\n  generateQr(@Body() generateQrDto: GenerateQrDto) {\r\n    return this.paymentsService.generateQr(generateQrDto);\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                      CallBack                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  @Post('qr/callback')\r\n  @UseGuards(BasicAuthGuard)\r\n  async receiveQrCallback(@Body() qrcallbackDto: QrCallbackDto) {\r\n    try {\r\n      //  Aquí validas si el Id existe en tu sistema\r\n      const id = qrcallbackDto.Id;\r\n\r\n      //  Procesas el pago\r\n      console.log('Pago recibido:', qrcallbackDto);\r\n\r\n      return {\r\n        State: '000',\r\n        Mensaje: 'COMPLETADO',\r\n        Data: {\r\n          id: id,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        State: '999',\r\n        Mensaje: 'ERROR',\r\n        Data: {\r\n          id: `E-${randomUUID()}`,\r\n        },\r\n      };\r\n    }\r\n  }\r\n}\r\n",
        "payments.module.ts": "import { Module } from '@nestjs/common';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\n\r\nimport { PaymentsController } from './payments.controller';\r\nimport { PaymentsService } from './payments.service';\r\nimport { PaymentQR } from './entities/payment-qr.entity';\r\n\r\nimport { HttpService } from './http/http.service';\r\n\r\nimport { TicketsModule } from '../tickets/tickets.module';\r\n\r\n@Module({\r\n  imports: [TypeOrmModule.forFeature([PaymentQR]), TicketsModule],\r\n  controllers: [PaymentsController],\r\n  providers: [PaymentsService, HttpService],\r\n})\r\nexport class PaymentsModule {}\r\n",
        "payments.service.ts": "import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository } from 'typeorm';\r\n\r\nimport { GenerateQrDto } from './dto/generate-qr.dto';\r\n\r\nimport { HttpService } from './http/http.service';\r\nimport { TicketsService } from '../tickets/tickets.service';\r\n\r\nimport { PaymentQR } from './entities/payment-qr.entity';\r\n\r\n@Injectable()\r\nexport class PaymentsService {\r\n  constructor(\r\n    @InjectRepository(PaymentQR)\r\n    private readonly paymentRepository: Repository<PaymentQR>,\r\n\r\n    private readonly httpService: HttpService,\r\n\r\n    private readonly ticketsService: TicketsService,\r\n  ) {}\r\n\r\n  async generateQr(dto: any /* GenerateQrDto */) {\r\n    try {\r\n      //! verificar que el ticket sea valido (que este pendiente)\r\n\r\n      const ticket = await this.ticketsService.findOneQr(dto.ticketId);\r\n      if (!ticket) throw new NotFoundException('Ticket not found or expired');\r\n\r\n      //const reserve_expiresAt = ticket.reserve_expiresAt\r\n\r\n      //! aumentar su validez 10 minutos y cambiar su estado a pagando\r\n\r\n      //! generar qr y devolver con el valor del ticket\r\n\r\n      const result = await this.httpService.generateQr(dto);\r\n\r\n      return result;\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        state: error.state || '99',\r\n        message: error.message || 'Error generando QR',\r\n        details: error.details,\r\n      };\r\n    }\r\n  }\r\n}\r\n"
      },
      "tickets": {
        "dto": {
          "assign-passenger-in-app.dto.ts": "import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsNumber } from 'class-validator';\r\n\r\nexport class AssignPassengerInAppDto {\r\n  @ApiProperty({\r\n    description: 'Ticket ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  ticketId: number;\r\n\r\n  @ApiProperty({\r\n    description: 'Seat ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  seatId: number;\r\n\r\n  @ApiProperty({\r\n    description: 'Passenger ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  passengerId: number;\r\n}\r\n",
          "assign-passenger-in-office.dto.ts": "import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsNumber } from 'class-validator';\r\n\r\nexport class AssignPassengerInOfficeDto {\r\n  @ApiProperty({\r\n    description: 'Ticket ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  ticketId: number;\r\n\r\n  @ApiProperty({\r\n    description: 'Seat ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  seatId: number;\r\n\r\n  @ApiProperty({\r\n    description: 'Passenger ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  passengerId: number;\r\n\r\n  @ApiProperty({\r\n    description: 'Customer ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  customerId: number;\r\n}\r\n",
          "create-ticket-in-app.dto.ts": "import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsNumber, ValidateNested } from 'class-validator';\r\nimport { Type } from 'class-transformer';\r\n\r\nimport { SeatSelectionInAppDto } from './selected-seats.dto';\r\n\r\nexport class CreateTicketInAppDto {\r\n  @ApiProperty({\r\n    description: 'Travel ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  travelId: number;\r\n\r\n  @ApiProperty({\r\n    type: [SeatSelectionInAppDto],\r\n    example: [{ seatId: '1' }, { seatId: '2' }],\r\n  })\r\n  @ValidateNested({ each: true })\r\n  @Type(() => SeatSelectionInAppDto)\r\n  seatSelections: SeatSelectionInAppDto[];\r\n}\r\n",
          "create-ticket-in-office.dto.ts": "import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsEnum, IsNumber, IsString, ValidateNested } from 'class-validator';\r\nimport { Type } from 'class-transformer';\r\n\r\nimport { SeatSelectionInOfficeDto } from './selected-seats.dto';\r\nimport { PaymentType } from '../enums/payment-type.enum';\r\n\r\nexport class CreateTicketInOfficeDto {\r\n  @ApiProperty({\r\n    description: 'Travel ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  travelId: number;\r\n\r\n  @ApiProperty({\r\n    type: [SeatSelectionInOfficeDto],\r\n    example: [\r\n      { seatId: '1', price: '40.00' },\r\n      { seatId: '2' }, //! usa precio por defecto\r\n    ],\r\n  })\r\n  @ValidateNested({ each: true })\r\n  @Type(() => SeatSelectionInOfficeDto)\r\n  seatSelections: SeatSelectionInOfficeDto[];\r\n\r\n  @ApiProperty({\r\n    description: 'Customer ID',\r\n    example: '1',\r\n  })\r\n  @IsNumber()\r\n  customerId: number;\r\n\r\n  @ApiProperty({\r\n    example: PaymentType.CASH,\r\n    enum: PaymentType,\r\n  })\r\n  @IsString()\r\n  @IsEnum(PaymentType)\r\n  payment_type: PaymentType;\r\n}\r\n",
          "index.ts": "export { CreateTicketInOfficeDto } from './create-ticket-in-office.dto';\r\nexport { CreateTicketInAppDto } from './create-ticket-in-app.dto';\r\n\r\nexport {\r\n  SelectedSeatsDto,\r\n  SeatSelectionInOfficeDto,\r\n  SeatSelectionInAppDto,\r\n} from './selected-seats.dto';\r\n\r\nexport { AssignPassengerInAppDto } from './assign-passenger-in-app.dto';\r\nexport { AssignPassengerInOfficeDto } from './assign-passenger-in-office.dto';\r\n",
          "selected-seats.dto.ts": "import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { IsNumberString, IsOptional, IsString } from 'class-validator';\r\n\r\n//! para guaradr en la entity\r\nexport class SelectedSeatsDto {\r\n  @IsString()\r\n  seatNumber: string;\r\n\r\n  @IsNumberString()\r\n  price: string;\r\n}\r\n\r\n//! para la creacion del ticket para el cajero\r\nexport class SeatSelectionInOfficeDto {\r\n  @ApiProperty({ example: '1' })\r\n  @IsString()\r\n  seatId: string;\r\n\r\n  @ApiPropertyOptional({ example: 45.5, required: false })\r\n  @IsOptional()\r\n  @IsNumberString()\r\n  price?: string;\r\n}\r\n\r\n//! para la creacion del ticket para la app\r\nexport class SeatSelectionInAppDto {\r\n  @ApiProperty({ example: '1' })\r\n  @IsString()\r\n  seatId: string;\r\n}\r\n"
        },
        "entities": {
          "ticket.entity.ts": "import {\r\n  Column,\r\n  Entity,\r\n  ManyToOne,\r\n  OneToMany,\r\n  CreateDateColumn,\r\n  DeleteDateColumn,\r\n  PrimaryGeneratedColumn,\r\n  Index,\r\n  OneToOne,\r\n  JoinColumn,\r\n} from 'typeorm';\r\n\r\nimport { SelectedSeatsDto } from '../dto';\r\n\r\nimport { TicketType } from '../enums/ticket-type.enum';\r\nimport { PaymentType } from '../enums/payment-type.enum';\r\nimport { TicketStatus } from '../enums/ticket-status.enum';\r\n\r\nimport { User } from 'src/modules/users/entities/user.entity';\r\nimport { Travel } from 'src/modules/travels/entities/travel.entity';\r\nimport { Customer } from 'src/modules/customers/entities/customer.entity';\r\nimport { PaymentQR } from 'src/modules/payments/entities/payment-qr.entity';\r\nimport { TravelSeat } from 'src/modules/travels/entities/travel-seat.entity';\r\n\r\n@Entity('tickets')\r\nexport class Ticket {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ type: 'text', default: TicketType.IN_OFFICE })\r\n  type: TicketType;\r\n\r\n  @Column({ type: 'text', default: PaymentType.CASH })\r\n  payment_type: PaymentType;\r\n\r\n  @Column({ type: 'text', default: TicketStatus.RESERVED })\r\n  status: TicketStatus;\r\n\r\n  @Column({ type: 'decimal', precision: 10, scale: 2 })\r\n  total_price: string;\r\n\r\n  @Column('json')\r\n  seats: SelectedSeatsDto[];\r\n\r\n  @Index()\r\n  @Column({ type: 'timestamptz', nullable: true })\r\n  reserve_expiresAt?: Date | null;\r\n\r\n  @CreateDateColumn({\r\n    type: 'timestamptz',\r\n  })\r\n  createdAt: Date;\r\n\r\n  @DeleteDateColumn({ nullable: true, select: false })\r\n  deletedAt: Date;\r\n\r\n  //* ============================================================================================== */\r\n  //*                                        Relations                                               */\r\n  //* ============================================================================================== */\r\n\r\n  @ManyToOne(() => Travel, (travel) => travel.tickets, { onDelete: 'CASCADE' })\r\n  travel: Travel;\r\n\r\n  @OneToMany(() => TravelSeat, (travelSeat) => travelSeat.ticket, {\r\n    cascade: true,\r\n  })\r\n  travelSeats: TravelSeat[];\r\n\r\n  @ManyToOne(() => User, (user) => user.ticketsSold, {\r\n    onDelete: 'SET NULL',\r\n    nullable: true, //! permitir null si la venta fue online\r\n  })\r\n  soldBy?: User | null;\r\n\r\n  @ManyToOne(() => Customer, (customer) => customer.ticketsBought, {\r\n    //onDelete: 'SET NULL',\r\n  })\r\n  buyer: Customer;\r\n\r\n  @OneToOne(() => PaymentQR, (paymentQr) => paymentQr.ticket, {\r\n    cascade: true,\r\n    nullable: true,\r\n  })\r\n  @JoinColumn()\r\n  paymentQr?: PaymentQR;\r\n}\r\n"
        },
        "enums": {
          "payment-type.enum.ts": "export enum PaymentType {\r\n  QR = 'qr',\r\n  CASH = 'cash',\r\n}\r\n",
          "ticket-status.enum.ts": "export enum TicketStatus {\r\n  RESERVED = 'reserved',\r\n  PENDING_PAYMENT = 'pending_payment',\r\n  SOLD = 'sold',\r\n  EXPIRED = 'expired',\r\n  CANCELLED = 'cancelled',\r\n  CANCELLED_FOR_CLOSE = 'cancelled_for_close',\r\n}\r\n",
          "ticket-type.enum.ts": "export enum TicketType {\r\n  IN_APP = 'IN_APP',\r\n  IN_OFFICE = 'IN_OFFICE',\r\n}\r\n"
        },
        "guards": {
          "is-penalty.guard.ts": "import {\r\n  Injectable,\r\n  CanActivate,\r\n  ExecutionContext,\r\n  UnauthorizedException,\r\n} from '@nestjs/common';\r\n\r\nimport { PenaltiesService } from 'src/modules/customers/penalties.service';\r\n\r\n@Injectable()\r\nexport class IsPenaltyGuard implements CanActivate {\r\n  constructor(private readonly reservationPenaltyService: PenaltiesService) {}\r\n\r\n  async canActivate(context: ExecutionContext): Promise<boolean> {\r\n    const request = context.switchToHttp().getRequest();\r\n    const customer = request.user;\r\n\r\n    if (!customer) {\r\n      throw new UnauthorizedException('Customer not found');\r\n    }\r\n\r\n    await this.reservationPenaltyService.validateReservation(customer);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
        },
        "services": {
          "ticket-expiration.service.ts": "import { Injectable } from '@nestjs/common';\r\nimport { DataSource, EntityManager, LessThan } from 'typeorm';\r\n\r\nimport { SeatStatus } from 'src/common/enums';\r\nimport { TicketType } from '../enums/ticket-type.enum';\r\nimport { TicketStatus } from '../enums/ticket-status.enum';\r\nimport { SaleType } from 'src/modules/travels/enums/sale_type-enum';\r\nimport { TravelStatus } from 'src/modules/travels/enums/travel-status.enum';\r\n\r\nimport { PenaltiesService } from 'src/modules/customers/penalties.service';\r\n\r\nimport { Ticket } from '../entities/ticket.entity';\r\n\r\n@Injectable()\r\nexport class TicketExpirationService {\r\n  constructor(\r\n    private readonly dataSource: DataSource,\r\n    private readonly penaltyService: PenaltiesService,\r\n  ) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                           ExpireTravelIfNeeded                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async expireTravelIfNeeded(\r\n    travelId: number,\r\n    manager?: EntityManager,\r\n  ): Promise<number> {\r\n    const internalManager = manager ?? this.dataSource.manager;\r\n\r\n    const expiredTickets = await internalManager.find(Ticket, {\r\n      where: {\r\n        travel: { id: travelId },\r\n        status: TicketStatus.RESERVED,\r\n        reserve_expiresAt: LessThan(new Date()),\r\n      },\r\n      relations: { travelSeats: true, buyer: true },\r\n    });\r\n\r\n    let expiredCount = 0;\r\n\r\n    for (const ticket of expiredTickets) {\r\n      ticket.status = TicketStatus.EXPIRED;\r\n      ticket.deletedAt = new Date();\r\n      //ticket.reserve_expiresAt = null;\r\n\r\n      for (const seat of ticket.travelSeats) {\r\n        seat.status = SeatStatus.AVAILABLE;\r\n        seat.ticket = null;\r\n        seat.sale_type = SaleType.UNSOLD;\r\n        seat.price = '0';\r\n        seat.passenger = null;\r\n        await internalManager.save(seat);\r\n      }\r\n\r\n      if (ticket.type === TicketType.IN_APP && ticket.buyer) {\r\n        await this.penaltyService.registerFailure(\r\n          ticket.buyer,\r\n          internalManager,\r\n        );\r\n      }\r\n\r\n      await internalManager.save(ticket);\r\n      expiredCount++;\r\n    }\r\n\r\n    return expiredCount;\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                   Expire_Batch                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async expireBatch(limit: number = 100): Promise<number> {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    try {\r\n      const expiredTickets = await queryRunner.manager\r\n        .createQueryBuilder(Ticket, 'ticket')\r\n        .leftJoinAndSelect('ticket.travelSeats', 'travelSeats')\r\n        .leftJoinAndSelect('ticket.buyer', 'buyer')\r\n        .leftJoin('ticket.travel', 'travel')\r\n        .where('ticket.status = :status', { status: TicketStatus.RESERVED })\r\n        .andWhere('ticket.reserve_expiresAt < NOW()')\r\n        .andWhere('travel.travel_status = :active', {\r\n          active: TravelStatus.ACTIVE,\r\n        })\r\n        .take(limit)\r\n        .getMany();\r\n\r\n      let expiredCount = 0;\r\n\r\n      for (const ticket of expiredTickets) {\r\n        ticket.status = TicketStatus.EXPIRED;\r\n        ticket.reserve_expiresAt = null;\r\n\r\n        for (const seat of ticket.travelSeats) {\r\n          seat.status = SeatStatus.AVAILABLE;\r\n          seat.ticket = null;\r\n          seat.sale_type = SaleType.UNSOLD;\r\n          seat.price = '0';\r\n          seat.passenger = null;\r\n          await queryRunner.manager.save(seat);\r\n        }\r\n\r\n        if (ticket.type === TicketType.IN_APP && ticket.buyer) {\r\n          await this.penaltyService.registerFailure(\r\n            ticket.buyer,\r\n            queryRunner.manager,\r\n          );\r\n        }\r\n\r\n        await queryRunner.manager.save(ticket);\r\n        expiredCount++;\r\n      }\r\n\r\n      await queryRunner.commitTransaction();\r\n      return expiredCount;\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      throw error;\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n}\r\n"
        },
        "tickets-for-cashiers.controller.ts": "import {\r\n  Get,\r\n  Post,\r\n  Body,\r\n  Param,\r\n  Controller,\r\n  ParseIntPipe,\r\n  Patch,\r\n} from '@nestjs/common';\r\nimport { ApiBearerAuth, ApiTags } from '@nestjs/swagger';\r\n\r\nimport { AssignPassengerInOfficeDto, CreateTicketInOfficeDto } from './dto';\r\n\r\nimport { ValidPermissions, ValidResourses } from 'src/common/enums';\r\n\r\nimport { Auth, GetUser, Resource } from '../../auth/decorators';\r\n\r\nimport { TicketsForCashierService } from './tickets-for-cashiers.service';\r\n\r\nimport { User } from '../users/entities/user.entity';\r\n\r\n//!\r\n@Resource(ValidResourses.TICKET_CASHIER)\r\n@ApiBearerAuth('access-token')\r\n//!\r\n\r\n@ApiTags('Tickets: For Cashiers')\r\n@Controller('tickets/for-cashier')\r\nexport class TicketsForCashiersController {\r\n  constructor(\r\n    private readonly ticketsForCashierService: TicketsForCashierService,\r\n  ) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        Create                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.CREATE)\r\n  //!\r\n  @Post()\r\n  create(\r\n    @Body() createTicketDto: CreateTicketInOfficeDto,\r\n    @GetUser() user: User,\r\n  ) {\r\n    return this.ticketsForCashierService.create(createTicketDto, user);\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        Confirm                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.CONFIRM)\r\n  //!\r\n  @Post('confirm/:id')\r\n  confirm(\r\n    @Param('id', ParseIntPipe) ticketId: number,\r\n    @GetUser() cashier: User,\r\n  ) {\r\n    return this.ticketsForCashierService.confirm(ticketId, cashier); //! GetCashier\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                         Cancel                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.CANCEL)\r\n  //!\r\n  @Post('cancel/:id')\r\n  cancel(\r\n    @Param('id', ParseIntPipe) ticketId: number,\r\n    @GetUser() cashier: User,\r\n  ) {\r\n    return this.ticketsForCashierService.cancel(ticketId, cashier); //! GetCashier\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindAll                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.READ)\r\n  //!\r\n  @Get(':travelId')\r\n  findAll(\r\n    @Param('travelId', ParseIntPipe) travelId: number,\r\n    @GetUser() cashier: User,\r\n  ) {\r\n    return this.ticketsForCashierService.findAll(travelId, cashier); //! GetCashier\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                Assign_Passenger                                                */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.UPDATE)\r\n  //!\r\n  @Patch('assign-passenger')\r\n  assignOccupantFromAdmin(@Body() dto: AssignPassengerInOfficeDto) {\r\n    return this.ticketsForCashierService.assignPassenger(dto);\r\n  }\r\n}\r\n",
        "tickets-for-cashiers.service.ts": "import {\r\n  Injectable,\r\n  NotFoundException,\r\n  BadRequestException,\r\n} from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { DataSource, Repository } from 'typeorm';\r\n\r\nimport { handleDBExceptions } from 'src/common/helpers/handleDBExceptions';\r\n\r\nimport { CreateTicketInOfficeDto, AssignPassengerInOfficeDto } from './dto';\r\n\r\nimport { SeatStatus } from 'src/common/enums';\r\nimport { TicketType } from './enums/ticket-type.enum';\r\nimport { TicketStatus } from './enums/ticket-status.enum';\r\nimport { SaleType } from '../travels/enums/sale_type-enum';\r\n\r\nimport { TicketsService } from './tickets.service';\r\nimport { TicketExpirationService } from './services/ticket-expiration.service';\r\n\r\nimport { Ticket } from './entities/ticket.entity';\r\nimport { User } from '../users/entities/user.entity';\r\nimport { Travel } from '../travels/entities/travel.entity';\r\nimport { Customer } from '../customers/entities/customer.entity';\r\nimport { PaymentType } from './enums/payment-type.enum';\r\n\r\n@Injectable()\r\nexport class TicketsForCashierService {\r\n  constructor(\r\n    @InjectRepository(Ticket)\r\n    private readonly ticketRepository: Repository<Ticket>,\r\n\r\n    @InjectRepository(Customer)\r\n    private readonly customerRepository: Repository<Customer>,\r\n\r\n    private readonly ticketsService: TicketsService,\r\n\r\n    private readonly ticketExpirationService: TicketExpirationService,\r\n\r\n    private dataSource: DataSource,\r\n  ) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                          Create                                                */\r\n  //? ============================================================================================== */\r\n\r\n  async create(dto: CreateTicketInOfficeDto, user: User) {\r\n    return this.ticketsService.createTicketBase({\r\n      dto,\r\n      user,\r\n      type: TicketType.IN_OFFICE,\r\n      paymentType: dto.payment_type,\r\n    });\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                      Confirm                                                   */\r\n  //? ============================================================================================== */\r\n\r\n  async confirm(ticketId: number, cashier: User) {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    try {\r\n      /* const ticketForTravel = await queryRunner.manager.findOne(Ticket, {\r\n        where: { id: ticketId },\r\n        select: { id: true, travel: true },\r\n        relations: { travel: true },\r\n      });\r\n\r\n      if (ticketForTravel) {\r\n        await this.ticketExpirationService.expireTravelIfNeeded(\r\n          ticketForTravel.travel.id,\r\n          queryRunner.manager,\r\n        );\r\n      } */\r\n\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { tickets: { id: ticketId } },\r\n      });\r\n      if (!travel) throw new NotFoundException('Travel not found');\r\n\r\n      //! --------------------------------------------\r\n      //! Expirar Reservas si es necesario\r\n      //! --------------------------------------------\r\n\r\n      await this.ticketExpirationService.expireTravelIfNeeded(\r\n        travel.id,\r\n        queryRunner.manager,\r\n      );\r\n\r\n      // --------------------------------------------\r\n      // 1. Buscar ticket con sus relaciones\r\n      // --------------------------------------------\r\n\r\n      const ticket = await queryRunner.manager\r\n        .createQueryBuilder(Ticket, 'ticket')\r\n        .setLock('pessimistic_write')\r\n\r\n        .innerJoinAndSelect('ticket.travelSeats', 'travelSeats')\r\n        .innerJoinAndSelect('ticket.travel', 'travel')\r\n\r\n        .innerJoin('travel.bus', 'bus')\r\n\r\n        .where('ticket.id = :ticketId', { ticketId })\r\n        .andWhere('bus.companyId = :companyId', {\r\n          companyId: cashier.office?.company.id, //! Solo de la misma empresa\r\n        })\r\n        .andWhere('ticket.status = :status', {\r\n          status: TicketStatus.RESERVED, //! Solo los reservados\r\n        })\r\n        .andWhere('ticket.type = :type', {\r\n          type: TicketType.IN_OFFICE, //! Solo en office\r\n        })\r\n        .andWhere('ticket.payment_type = :payment_type', {\r\n          payment_type: PaymentType.CASH, //! Solo en cash\r\n        })\r\n        .andWhere('(ticket.reserve_expiresAt > NOW())') //! No expirado\r\n        .getOne();\r\n\r\n      if (!ticket)\r\n        throw new NotFoundException(\r\n          'Ticket not found, expired, or not in a confirmable state',\r\n        );\r\n\r\n      // --------------------------------------------\r\n      // 2. Actualizar estados\r\n      // --------------------------------------------\r\n\r\n      ticket.status = TicketStatus.SOLD;\r\n      ticket.reserve_expiresAt = null; //! (para la limpieza)\r\n\r\n      for (const seat of ticket.travelSeats) {\r\n        seat.status = SeatStatus.SOLD;\r\n        seat.sale_type = SaleType.OFFICE;\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 3. Persistir cambios\r\n      // --------------------------------------------\r\n\r\n      await queryRunner.manager.save(Ticket, ticket);\r\n      await queryRunner.commitTransaction();\r\n\r\n      return {\r\n        message: 'Ticket payment confirmed successfully',\r\n        ticket: ticket,\r\n      };\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      handleDBExceptions(error);\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                     Confirm_QR                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async confirmTicketQr() {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        Cancel                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  async cancel(ticketId: number, cashier: User) {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    try {\r\n      /* const ticketForTravel = await queryRunner.manager.findOne(Ticket, {\r\n        where: { id: ticketId },\r\n        select: { id: true, travel: true },\r\n        relations: { travel: true },\r\n      });\r\n\r\n      if (ticketForTravel) {\r\n        await this.ticketExpirationService.expireTravelIfNeeded(\r\n          ticketForTravel.travel.id,\r\n          queryRunner.manager,\r\n        );\r\n      } */\r\n\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { tickets: { id: ticketId } },\r\n      });\r\n      if (!travel) throw new NotFoundException('Travel not found');\r\n\r\n      //! --------------------------------------------\r\n      //! Expirar Reservas si es necesario\r\n      //! --------------------------------------------\r\n\r\n      await this.ticketExpirationService.expireTravelIfNeeded(\r\n        travel.id,\r\n        queryRunner.manager,\r\n      );\r\n\r\n      // --------------------------------------------\r\n      // 1. Buscar ticket con sus relaciones\r\n      // --------------------------------------------\r\n\r\n      const ticket = await queryRunner.manager\r\n        .createQueryBuilder(Ticket, 'ticket')\r\n        .setLock('pessimistic_write')\r\n\r\n        .innerJoinAndSelect('ticket.travelSeats', 'travelSeats')\r\n        .innerJoinAndSelect('ticket.travel', 'travel')\r\n\r\n        .innerJoin('travel.bus', 'bus')\r\n        .innerJoin('bus.owner', 'owner')\r\n        .innerJoin('owner.companies', 'company')\r\n\r\n        .where('ticket.id = :ticketId', { ticketId }) //! Por ID\r\n        .andWhere('company.id = :companyId', {\r\n          companyId: cashier.office?.company.id, //! Solo de la misma empresa\r\n        })\r\n        .andWhere('ticket.status IN (:...statuses)', {\r\n          statuses: [TicketStatus.SOLD, TicketStatus.RESERVED], //! Solo los vendidos o reservados\r\n        })\r\n        .andWhere('ticket.type = :type', { type: TicketType.IN_OFFICE }) //! Solo en office\r\n        .andWhere(\r\n          '(ticket.reserve_expiresAt IS NULL OR ticket.reserve_expiresAt > NOW())', //! No expirado\r\n        )\r\n        .getOne();\r\n\r\n      if (!ticket) throw new NotFoundException('Ticket not found or expired');\r\n\r\n      // --------------------------------------------\r\n      // 2. Validaciones de negocio\r\n      // --------------------------------------------\r\n\r\n      if (!this.isTicketCancelable(ticket)) {\r\n        throw new BadRequestException(\r\n          `Cannot cancel a ticket with status \"${ticket.status}\"`,\r\n        );\r\n      }\r\n\r\n      //! agregar despues\r\n      /* if (this.hasTravelDeparted(ticket.travel)) {\r\n        throw new BadRequestException(\r\n          'Cannot cancel a ticket for a travel that has already departed',\r\n        );\r\n      } */\r\n\r\n      // --------------------------------------------\r\n      // 3. Actualizar estados\r\n      // --------------------------------------------\r\n\r\n      switch (ticket.status) {\r\n        case TicketStatus.SOLD:\r\n          ticket.status = TicketStatus.CANCELLED;\r\n          ticket.reserve_expiresAt = null;\r\n          break;\r\n\r\n        case TicketStatus.RESERVED:\r\n          ticket.status = TicketStatus.CANCELLED;\r\n          ticket.reserve_expiresAt = null;\r\n          ticket.deletedAt = new Date();\r\n          break;\r\n      }\r\n\r\n      for (const seat of ticket.travelSeats) {\r\n        seat.status = SeatStatus.AVAILABLE;\r\n        seat.sale_type = SaleType.UNSOLD;\r\n        seat.ticket = null; //! desasociar el asiento del ticket\r\n        seat.price = '0'; //! resetear el precio\r\n        seat.passenger = null; //! desasociar el pasajero\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 4. Persistir cambios\r\n      // --------------------------------------------\r\n\r\n      await queryRunner.manager.save(Ticket, ticket);\r\n      await queryRunner.commitTransaction();\r\n\r\n      return {\r\n        message: 'Ticket canceled successfully',\r\n        ticketId: ticket,\r\n      };\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      handleDBExceptions(error);\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private isTicketCancelable(ticket: Ticket): boolean {\r\n    return [TicketStatus.RESERVED, TicketStatus.SOLD].includes(ticket.status);\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private hasTravelDeparted(travel: Travel): boolean {\r\n    return travel.departure_time <= new Date();\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindAll                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async findAll(travelId: number, cashier: User) {\r\n    //! --------------------------------------------\r\n    //! Expirar Reservas si es necesario\r\n    //! --------------------------------------------\r\n\r\n    await this.ticketExpirationService.expireTravelIfNeeded(travelId);\r\n\r\n    const tickets = await this.ticketRepository.find({\r\n      order: { id: 'DESC' },\r\n      where: {\r\n        travel: { id: travelId },\r\n        soldBy: { id: cashier.id },\r\n      },\r\n      relations: { travelSeats: true, buyer: true },\r\n    });\r\n    return tickets;\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindOne                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  /* async findOne(id: number, admin: User) {\r\n      const ticket = await this.ticketRepository.findOneBy({\r\n        id,\r\n        travel: {\r\n          bus: { owner: { companies: admin.company } },\r\n        },\r\n      });\r\n      if (!ticket) throw new NotFoundException('Ticket not found');\r\n      return ticket;\r\n    } */\r\n\r\n  //? ============================================================================================== */\r\n  //?                               Assign_Passenger                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async assignPassenger(dto: AssignPassengerInOfficeDto) {\r\n    const customer = await this.customerRepository.findOne({\r\n      where: { id: dto.customerId },\r\n    });\r\n\r\n    if (!customer) {\r\n      throw new NotFoundException('Customer not found');\r\n    }\r\n    return this.ticketsService.assignPassengerBase(\r\n      dto.ticketId,\r\n      dto.seatId,\r\n      dto.passengerId,\r\n      customer,\r\n    );\r\n  }\r\n}\r\n",
        "tickets-in-app.controller.ts": "import {\r\n  Body,\r\n  Get,\r\n  Param,\r\n  Patch,\r\n  Post,\r\n  UseGuards,\r\n  Controller,\r\n  ParseIntPipe,\r\n} from '@nestjs/common';\r\nimport { ApiBearerAuth, ApiTags } from '@nestjs/swagger';\r\n\r\nimport { AssignPassengerInAppDto, CreateTicketInAppDto } from './dto';\r\n\r\nimport { ValidResourses } from 'src/common/enums';\r\n\r\nimport { Auth, GetCustomer, Resource } from '../../auth/decorators';\r\n\r\nimport { IsVerifyGuard } from 'src/auth/guards';\r\nimport { IsPenaltyGuard } from './guards/is-penalty.guard';\r\n\r\nimport { Customer } from '../customers/entities/customer.entity';\r\n\r\nimport { TicketsInAppService } from './tickets-in-app.service';\r\n\r\n//!\r\n@Resource(ValidResourses.TICKET_APP)\r\n@ApiBearerAuth('access-token')\r\n//!\r\n\r\n@ApiTags('Tickets: In App')\r\n@Controller('tickets/in-app')\r\nexport class TicketsInAppController {\r\n  constructor(private readonly ticketsInAppService: TicketsInAppService) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        Create                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n\r\n  @UseGuards(IsVerifyGuard, IsPenaltyGuard)\r\n  @Auth()\r\n  //!\r\n  @Post()\r\n  create(\r\n    @Body() createTicketDto: CreateTicketInAppDto,\r\n    @GetCustomer() customer: Customer,\r\n  ) {\r\n    return this.ticketsInAppService.create(createTicketDto, customer); //! GetCustomer\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                         Cancel                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @UseGuards(IsVerifyGuard)\r\n  @Auth()\r\n  //!\r\n  @Post('cancel/:id')\r\n  cancel(\r\n    @Param('id', ParseIntPipe) ticketId: number,\r\n    @GetCustomer() customer: Customer,\r\n  ) {\r\n    return this.ticketsInAppService.cancel(ticketId, customer); //! GetCustomer\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                       FindAll                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @UseGuards(IsVerifyGuard)\r\n  @Auth()\r\n  //!\r\n  @Get('all')\r\n  findAll(@GetCustomer() customer: Customer) {\r\n    return this.ticketsInAppService.findAll(customer); //! GetCustomer\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                               Assign-Passenger                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @UseGuards(IsVerifyGuard)\r\n  @Auth()\r\n  //!\r\n  @Patch('assign-passenger')\r\n  assignOccupant(\r\n    @Body() dto: AssignPassengerInAppDto,\r\n    @GetCustomer() customer: Customer,\r\n  ) {\r\n    return this.ticketsInAppService.assignPassenger(dto, customer); //! GetCustomer\r\n  }\r\n}\r\n",
        "tickets-in-app.service.ts": "import {\r\n  Injectable,\r\n  BadRequestException,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { DataSource, Repository } from 'typeorm';\r\n\r\nimport { handleDBExceptions } from 'src/common/helpers/handleDBExceptions';\r\n\r\nimport { CreateTicketInAppDto, AssignPassengerInAppDto } from './dto';\r\n\r\nimport { SeatStatus } from 'src/common/enums';\r\nimport { TicketType } from './enums/ticket-type.enum';\r\nimport { PaymentType } from './enums/payment-type.enum';\r\nimport { TicketStatus } from './enums/ticket-status.enum';\r\nimport { SaleType } from '../travels/enums/sale_type-enum';\r\n\r\nimport { TicketsService } from './tickets.service';\r\nimport { TicketExpirationService } from './services/ticket-expiration.service';\r\n\r\nimport { Ticket } from './entities/ticket.entity';\r\nimport { Travel } from '../travels/entities/travel.entity';\r\nimport { Customer } from '../customers/entities/customer.entity';\r\n\r\n@Injectable()\r\nexport class TicketsInAppService {\r\n  constructor(\r\n    @InjectRepository(Ticket)\r\n    private readonly ticketRepository: Repository<Ticket>,\r\n\r\n    @InjectRepository(Travel)\r\n    private readonly travelRepository: Repository<Travel>,\r\n\r\n    private readonly ticketsService: TicketsService,\r\n\r\n    private readonly ticketExpirationService: TicketExpirationService,\r\n\r\n    private dataSource: DataSource,\r\n  ) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                         Create                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async create(dto: CreateTicketInAppDto, buyer: Customer) {\r\n    return this.ticketsService.createTicketBase({\r\n      dto,\r\n      buyer,\r\n      type: TicketType.IN_APP,\r\n      paymentType: PaymentType.QR,\r\n    });\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                       FindAll                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  async findAll(customer: Customer) {\r\n    //! --------------------------------------------\r\n    //! Expirar Reservas si es necesario\r\n    //! --------------------------------------------\r\n\r\n    const travelsToExpire = await this.travelRepository.find({\r\n      select: { id: true },\r\n      /* where:{} */\r\n    });\r\n\r\n    for (const travel of travelsToExpire) {\r\n      await this.ticketExpirationService.expireTravelIfNeeded(travel.id);\r\n    }\r\n\r\n    return await this.ticketRepository.find({\r\n      where: {\r\n        buyer: { id: customer.id },\r\n      },\r\n    });\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        Cancel                                                  */\r\n  //? ============================================================================================== */\r\n\r\n  async cancel(ticketId: number, customer: Customer) {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    try {\r\n      /* const ticketForTravel = await queryRunner.manager.findOne(Ticket, {\r\n        where: { id: ticketId },\r\n        select: { id: true, travel: true },\r\n        relations: { travel: true },\r\n      });\r\n\r\n      if (ticketForTravel) {\r\n        await this.ticketExpirationService.expireTravelIfNeeded(\r\n          ticketForTravel.travel.id,\r\n          queryRunner.manager,\r\n        );\r\n      } */\r\n\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { tickets: { id: ticketId } },\r\n      });\r\n      if (!travel) throw new NotFoundException('Travel not found');\r\n\r\n      //! --------------------------------------------\r\n      //! Expirar Reservas si es necesario\r\n      //! --------------------------------------------\r\n\r\n      await this.ticketExpirationService.expireTravelIfNeeded(\r\n        travel.id,\r\n        queryRunner.manager,\r\n      );\r\n\r\n      // --------------------------------------------\r\n      // 1. Buscar ticket con sus relaciones\r\n      // --------------------------------------------\r\n\r\n      const ticket = await queryRunner.manager\r\n        .createQueryBuilder(Ticket, 'ticket')\r\n        .setLock('pessimistic_write')\r\n\r\n        .innerJoinAndSelect('ticket.travelSeats', 'travelSeats')\r\n        .innerJoinAndSelect('ticket.travel', 'travel')\r\n\r\n        //.innerJoin('travel.bus', 'bus')\r\n        //.innerJoin('bus.owner', 'owner')\r\n        //.innerJoin('owner.companies', 'company')\r\n\r\n        .where('ticket.id = :ticketId', { ticketId }) //! Por ID\r\n        .andWhere('ticket.buyerId = :buyerId', {\r\n          buyerId: customer.id, //! la misma persona\r\n        })\r\n        .andWhere('ticket.status IN (:...statuses)', {\r\n          statuses: [TicketStatus.SOLD, TicketStatus.RESERVED], //! Solo los vendidos o reservados\r\n        })\r\n        .andWhere('ticket.type = :type', { type: TicketType.IN_APP }) //! Solo en app\r\n        .andWhere(\r\n          '(ticket.reserve_expiresAt IS NULL OR ticket.reserve_expiresAt > NOW())', //! No expirado\r\n        )\r\n        .getOne();\r\n\r\n      if (!ticket) throw new NotFoundException('Ticket not found or expired');\r\n\r\n      // --------------------------------------------\r\n      // 2. Validaciones de negocio\r\n      // --------------------------------------------\r\n\r\n      if (!this.isTicketCancelable(ticket)) {\r\n        throw new BadRequestException(\r\n          `Cannot cancel a ticket with status \"${ticket.status}\"`,\r\n        );\r\n      }\r\n\r\n      /* if (this.hasTravelDeparted(ticket.travel)) {\r\n        throw new BadRequestException(\r\n          'Cannot cancel a ticket for a travel that has already departed',\r\n        );\r\n      } */\r\n\r\n      // --------------------------------------------\r\n      // 3. Actualizar estados\r\n      // --------------------------------------------\r\n\r\n      switch (ticket.status) {\r\n        case TicketStatus.SOLD:\r\n          ticket.status = TicketStatus.CANCELLED;\r\n          ticket.reserve_expiresAt = null;\r\n          break;\r\n\r\n        case TicketStatus.RESERVED:\r\n          ticket.status = TicketStatus.CANCELLED;\r\n          ticket.reserve_expiresAt = null;\r\n          ticket.deletedAt = new Date();\r\n          break;\r\n      }\r\n\r\n      for (const seat of ticket.travelSeats) {\r\n        seat.status = SeatStatus.AVAILABLE;\r\n        seat.sale_type = SaleType.UNSOLD;\r\n        seat.ticket = null; //! desasociar el asiento del ticket\r\n        seat.price = '0'; //! resetear el precio\r\n        seat.passenger = null; //! desasociar el pasajero\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 4. Persistir cambios\r\n      // --------------------------------------------\r\n\r\n      await queryRunner.manager.save(Ticket, ticket);\r\n      await queryRunner.commitTransaction();\r\n\r\n      return {\r\n        message: 'Ticket canceled successfully',\r\n        ticket: ticket,\r\n      };\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      handleDBExceptions(error);\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private isTicketCancelable(ticket: Ticket): boolean {\r\n    return [TicketStatus.RESERVED, TicketStatus.SOLD].includes(ticket.status);\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private hasTravelDeparted(travel: Travel): boolean {\r\n    return travel.departure_time <= new Date();\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                               Assign_Passenger                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async assignPassenger(dto: AssignPassengerInAppDto, customer: Customer) {\r\n    return this.ticketsService.assignPassengerBase(\r\n      dto.ticketId,\r\n      dto.seatId,\r\n      dto.passengerId,\r\n      customer,\r\n    );\r\n  }\r\n}\r\n",
        "tickets.controller.ts": "import { Get, Param, Controller, ParseIntPipe } from '@nestjs/common';\r\nimport { ApiBearerAuth, ApiQuery, ApiTags } from '@nestjs/swagger';\r\n\r\nimport { ValidPermissions, ValidResourses } from 'src/common/enums';\r\n\r\nimport { Auth, GetCompany, Resource } from '../../auth/decorators';\r\n\r\nimport { TicketsService } from './tickets.service';\r\n\r\n//!\r\n@Resource(ValidResourses.TICKET)\r\n@ApiBearerAuth('access-token')\r\n//!\r\n\r\n@ApiTags('Tickets')\r\n@Controller('tickets')\r\nexport class TicketsController {\r\n  constructor(private readonly ticketsService: TicketsService) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindAll                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  //!\r\n  @Auth(ValidPermissions.READ)\r\n  //!\r\n  @ApiQuery({ name: 'companyId', required: false, type: Number })\r\n  @Get(':travelId')\r\n  findAll(\r\n    @Param('travelId', ParseIntPipe) travelId: number,\r\n    @GetCompany() companyId: number,\r\n  ) {\r\n    return this.ticketsService.findAll(companyId, travelId); //! GetCompany\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindOne                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  /* //!\r\n  @Auth(ValidPermissions.READ)\r\n  //!\r\n  @Get(':id')\r\n  findOne(@Param('id', ParseIntPipe) id: number, @GetUser() admin: User) {\r\n    return this.ticketsService.findOne(id, admin); //! GetUser\r\n  } */\r\n}\r\n",
        "tickets.module.ts": "import { forwardRef, Module } from '@nestjs/common';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\n\r\nimport { TicketsController } from './tickets.controller';\r\nimport { TicketsService } from './tickets.service';\r\nimport { Ticket } from './entities/ticket.entity';\r\n\r\nimport { CustomersModule } from '../customers/customers.module';\r\nimport { TicketsForCashiersController } from './tickets-for-cashiers.controller';\r\nimport { TravelsModule } from '../travels/travels.module';\r\nimport { TicketsInAppController } from './tickets-in-app.controller';\r\n\r\nimport { TicketsForCashierService } from './tickets-for-cashiers.service';\r\nimport { TicketsInAppService } from './tickets-in-app.service';\r\n\r\nimport { TicketExpirationService } from './services/ticket-expiration.service';\r\n\r\n@Module({\r\n  imports: [\r\n    TypeOrmModule.forFeature([Ticket]),\r\n    CustomersModule,\r\n    forwardRef(() => TravelsModule),\r\n  ],\r\n  controllers: [\r\n    TicketsController,\r\n    TicketsInAppController,\r\n    TicketsForCashiersController,\r\n  ],\r\n  providers: [\r\n    TicketsService,\r\n    TicketsInAppService,\r\n    TicketsForCashierService,\r\n    TicketExpirationService,\r\n  ],\r\n  exports: [TicketExpirationService, TicketsService],\r\n})\r\nexport class TicketsModule {}\r\n",
        "tickets.service.ts": "import {\r\n  Injectable,\r\n  NotFoundException,\r\n  BadRequestException,\r\n} from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { DataSource, Repository } from 'typeorm';\r\n\r\nimport { envs } from 'src/config/environments/environments';\r\n\r\nimport { handleDBExceptions } from 'src/common/helpers/handleDBExceptions';\r\n\r\nimport {\r\n  SelectedSeatsDto,\r\n  CreateTicketInAppDto,\r\n  CreateTicketInOfficeDto,\r\n} from './dto';\r\n\r\nimport { SeatStatus } from 'src/common/enums';\r\nimport { TicketType } from './enums/ticket-type.enum';\r\nimport { TicketStatus } from './enums/ticket-status.enum';\r\nimport { TravelStatus } from '../travels/enums/travel-status.enum';\r\n\r\nimport { CustomersService } from '../customers/customers.service';\r\nimport { PenaltiesService } from '../customers/penalties.service';\r\nimport { TicketExpirationService } from './services/ticket-expiration.service';\r\n\r\nimport { Ticket } from './entities/ticket.entity';\r\nimport { User } from '../users/entities/user.entity';\r\nimport { Travel } from '../travels/entities/travel.entity';\r\nimport { Customer } from '../customers/entities/customer.entity';\r\nimport { Passenger } from '../customers/entities/passenger.entity';\r\nimport { TravelSeat } from '../travels/entities/travel-seat.entity';\r\nimport { PaymentType } from './enums/payment-type.enum';\r\n\r\n@Injectable()\r\nexport class TicketsService {\r\n  constructor(\r\n    @InjectRepository(Ticket)\r\n    private readonly ticketRepository: Repository<Ticket>,\r\n\r\n    private readonly customersService: CustomersService,\r\n\r\n    private readonly penaltiesService: PenaltiesService,\r\n\r\n    private readonly ticketExpirationService: TicketExpirationService,\r\n\r\n    private dataSource: DataSource,\r\n  ) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                          Create                                                */\r\n  //? ============================================================================================== */\r\n\r\n  async createTicketBase({\r\n    dto,\r\n    buyer,\r\n    user,\r\n    type,\r\n    paymentType,\r\n  }: {\r\n    dto: CreateTicketInAppDto | CreateTicketInOfficeDto;\r\n    buyer?: Customer;\r\n    user?: User;\r\n    type: TicketType;\r\n    paymentType: PaymentType;\r\n  }) {\r\n    const { travelId, seatSelections } = dto;\r\n\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    //! --------------------------------------------\r\n    //! Expirar Reservas si es necesario\r\n    //! --------------------------------------------\r\n\r\n    await this.ticketExpirationService.expireTravelIfNeeded(\r\n      travelId,\r\n      queryRunner.manager,\r\n    );\r\n\r\n    try {\r\n      // --------------------------------------------\r\n      // 1. Obtener Viaje y validar\r\n      // --------------------------------------------\r\n\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { id: travelId },\r\n        relations: { bus: true },\r\n      });\r\n      if (!travel) throw new NotFoundException('Travel not found');\r\n\r\n      if (travel.travel_status !== TravelStatus.ACTIVE)\r\n        throw new BadRequestException('Travel is not active');\r\n\r\n      // --------------------------------------------\r\n      // 2. Obtener Seats\r\n      // --------------------------------------------\r\n\r\n      const seatIds = seatSelections.map((s) => s.seatId);\r\n      const seats = await queryRunner.manager\r\n        .createQueryBuilder(TravelSeat, 'seat')\r\n        .setLock('pessimistic_write')\r\n        .where('seat.id IN (:...seatIds)', { seatIds })\r\n        .andWhere('seat.travelId = :travelId', { travelId })\r\n        .andWhere('seat.deletedAt IS NULL')\r\n        .andWhere(`(seat.status = :available )`, {\r\n          available: SeatStatus.AVAILABLE,\r\n        })\r\n        .getMany();\r\n\r\n      // --------------------------------------------\r\n      // 3. Validar disponibilidad y que no sean espacios\r\n      // --------------------------------------------\r\n\r\n      const seatsCleaned = [...seats];\r\n      for (const seat of seats) {\r\n        if (seat.seatNumber === '0') {\r\n          seatsCleaned.splice(seatsCleaned.indexOf(seat), 1);\r\n        }\r\n      }\r\n\r\n      if (seatsCleaned.length !== seatIds.length) {\r\n        const foundIds = seatsCleaned.map((s) => s.id.toString());\r\n        const missing = seatIds.filter((id) => !foundIds.includes(id));\r\n        throw new BadRequestException(\r\n          `Some seats are unavailable or already sold: ${missing.join(', ')}`,\r\n        );\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 4. Obtener el customer\r\n      // --------------------------------------------\r\n\r\n      if (type === TicketType.IN_OFFICE && !buyer) {\r\n        const officeDto = dto as CreateTicketInOfficeDto;\r\n        buyer = await this.customersService.findOne(\r\n          officeDto.customerId,\r\n          queryRunner.manager,\r\n        );\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 5. Calcular precios y cambiar estados\r\n      // --------------------------------------------\r\n\r\n      let totalPrice = 0;\r\n\r\n      for (const seat of seats) {\r\n        const selection = seatSelections.find(\r\n          (s) => s.seatId.toString() === seat.id.toString(),\r\n        );\r\n        const finalPrice = this.resolveSeatPrice(selection, seat, travel);\r\n        seat.price = finalPrice.toFixed(2);\r\n        seat.status = SeatStatus.RESERVED;\r\n        totalPrice += finalPrice;\r\n      }\r\n\r\n      // --------------------------------------------\r\n      // 6. Crear ticket y actualizar seats\r\n      // --------------------------------------------\r\n\r\n      const seatsArray: SelectedSeatsDto[] = seats.map((s) => {\r\n        return {\r\n          id: s.id,\r\n          seatNumber: s.seatNumber,\r\n          price: s.price,\r\n        };\r\n      });\r\n\r\n      const expires = this.getReservationExpiry(); //! get fecha de expiracion\r\n\r\n      const ticket = queryRunner.manager.create(Ticket, {\r\n        type,\r\n        travel,\r\n        buyer,\r\n        seats: seatsArray,\r\n        soldBy: type === TicketType.IN_OFFICE ? user : null,\r\n        travelSeats: seats,\r\n        total_price: totalPrice.toFixed(2),\r\n        reserve_expiresAt: expires,\r\n        payment_type: paymentType,\r\n      });\r\n\r\n      // --------------------------------------------\r\n      // 7. Persistir cambios\r\n      // --------------------------------------------\r\n\r\n      await queryRunner.manager.save(ticket);\r\n\r\n      // --------------------------------------------\r\n      // 8. Logica de penalizacion\r\n      // --------------------------------------------\r\n\r\n      if (buyer && !user)\r\n        await this.penaltiesService.registerFailure(buyer, queryRunner.manager);\r\n\r\n      await queryRunner.commitTransaction();\r\n\r\n      return ticket;\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      handleDBExceptions(error);\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private getReservationExpiry(): Date {\r\n    const minutes = envs.RESERVATION_EXPIRE_MINUTES || 10;\r\n    const now = new Date();\r\n    return new Date(now.getTime() + minutes * 60 * 1000);\r\n  }\r\n\r\n  //* ============================================================================================== */\r\n\r\n  private resolveSeatPrice(\r\n    selection: { seatId: string; price?: string } | undefined,\r\n    seat: TravelSeat,\r\n    travel: Travel,\r\n  ): number {\r\n    if (selection?.price && !isNaN(Number(selection.price))) {\r\n      return Number(selection.price);\r\n    }\r\n    if (!travel.price_deck_2) {\r\n      return Number(travel.price_deck_1);\r\n    }\r\n    return seat.deck === 2\r\n      ? Number(travel.price_deck_2 || travel.price_deck_1)\r\n      : Number(travel.price_deck_1);\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                              Confirm_Ticket_QR                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async confirmTicketQr(qrDataInterface: any) {}\r\n\r\n  //? ============================================================================================== */\r\n  //?                                        FindAll                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async findAll(companyId: number, travelId: number) {\r\n    //! --------------------------------------------\r\n    //! Expirar Reservas si es necesario\r\n    //! --------------------------------------------\r\n\r\n    await this.ticketExpirationService.expireTravelIfNeeded(travelId);\r\n\r\n    const tickets = await this.ticketRepository.find({\r\n      where: {\r\n        travel: {\r\n          id: travelId,\r\n          bus: { owner: { companies: { id: companyId } } },\r\n        },\r\n      },\r\n    });\r\n    return tickets;\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                                     FindOne_Qr                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async findOneQr(ticketId: number) {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    try {\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { tickets: { id: ticketId } },\r\n      });\r\n      if (!travel) throw new NotFoundException('Travel not found');\r\n\r\n      //! --------------------------------------------\r\n      //! Expirar Reservas si es necesario\r\n      //! --------------------------------------------\r\n\r\n      await this.ticketExpirationService.expireTravelIfNeeded(\r\n        travel.id,\r\n        queryRunner.manager,\r\n      );\r\n\r\n      const ticket = await queryRunner.manager\r\n        .createQueryBuilder(Ticket, 'ticket')\r\n        .setLock('pessimistic_write')\r\n        .where('ticket.id = :ticketId', { ticketId }) //! Por ID\r\n        .andWhere('ticket.status IN (:...statuses)', {\r\n          statuses: [TicketStatus.RESERVED],\r\n        })\r\n        .andWhere('ticket.payment_type = :payment_type', {\r\n          payment_type: PaymentType.QR, //! Solo QR\r\n        })\r\n        .andWhere(\r\n          '(ticket.reserve_expiresAt IS NULL OR ticket.reserve_expiresAt > NOW())', //! No expirado\r\n        )\r\n        .getOne();\r\n\r\n      if (!ticket) throw new NotFoundException('Ticket not found or expired');\r\n\r\n      await queryRunner.commitTransaction();\r\n\r\n      return ticket;\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      handleDBExceptions(error);\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n\r\n  //? ============================================================================================== */\r\n  //?                               Assign_Passenger                                                 */\r\n  //? ============================================================================================== */\r\n\r\n  async assignPassengerBase(\r\n    ticketId: number,\r\n    seatId: number,\r\n    passengerId: number,\r\n    customer: Customer,\r\n  ) {\r\n    const queryRunner = this.dataSource.createQueryRunner();\r\n    await queryRunner.connect();\r\n    await queryRunner.startTransaction();\r\n\r\n    //! --------------------------------------------\r\n    //! Expirar Reservas si es necesario\r\n    //! --------------------------------------------\r\n\r\n    try {\r\n      const travel = await queryRunner.manager.findOne(Travel, {\r\n        where: { tickets: { id: ticketId } },\r\n        select: ['id'],\r\n      });\r\n\r\n      if (!travel) {\r\n        throw new NotFoundException('Travel not found');\r\n      }\r\n\r\n      await this.ticketExpirationService.expireTravelIfNeeded(\r\n        travel.id,\r\n        queryRunner.manager,\r\n      );\r\n\r\n      const seat = await queryRunner.manager\r\n        .createQueryBuilder(TravelSeat, 'seat')\r\n        .leftJoinAndSelect('seat.ticket', 'ticket')\r\n        .where('seat.id = :seatId', { seatId })\r\n        .andWhere('ticket.id = :ticketId', { ticketId })\r\n        .andWhere('ticket.buyerId = :customerId', {\r\n          customerId: customer.id,\r\n        })\r\n        .andWhere('ticket.status = :status', {\r\n          status: TicketStatus.RESERVED,\r\n        })\r\n        .getOne();\r\n\r\n      if (!seat) {\r\n        throw new BadRequestException('Seat not editable');\r\n      }\r\n\r\n      const passenger = await queryRunner.manager.findOne(Passenger, {\r\n        where: {\r\n          id: passengerId,\r\n          customer: { id: customer.id },\r\n        },\r\n      });\r\n\r\n      if (!passenger) {\r\n        throw new NotFoundException('Passenger not found');\r\n      }\r\n\r\n      seat.passenger = {\r\n        name: passenger.fullName,\r\n        ci: passenger.ci,\r\n      };\r\n\r\n      await queryRunner.manager.save(seat);\r\n\r\n      await queryRunner.commitTransaction();\r\n      return seat;\r\n    } catch (error) {\r\n      await queryRunner.rollbackTransaction();\r\n      throw error;\r\n    } finally {\r\n      await queryRunner.release();\r\n    }\r\n  }\r\n}\r\n"
      }
    }
  }
}